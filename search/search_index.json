{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Our Roleplaying Game Framework This project has been developed by Group 5 of our Software Engineering II Class. To browse our documentation, please use the website navigation above!","title":"Welcome to Our Roleplaying Game Framework"},{"location":"#welcome-to-our-roleplaying-game-framework","text":"This project has been developed by Group 5 of our Software Engineering II Class. To browse our documentation, please use the website navigation above!","title":"Welcome to Our Roleplaying Game Framework"},{"location":"Manual/","text":"Manual Here we've recorded explanations and descriptions of all the components of the project. The point is to give new users a place to get started and learn what our framework has to offer without having to dig in and read the code.","title":"Manual"},{"location":"Manual/#manual","text":"Here we've recorded explanations and descriptions of all the components of the project. The point is to give new users a place to get started and learn what our framework has to offer without having to dig in and read the code.","title":"Manual"},{"location":"Manual/Attacking/","text":"Attacking Our Attacking is a simple amie and fire system to damage the NPCs in the environment. This also correlates to the health bar on the NPCs. If the NPC doesn't have a health bar over it, you will not be able to attack it. Attacking Script Modifyable Variables These variables are open to your configuration to customize your controller the attck you want. Stats A reference to the player states. Projectile A reference to the projectile that the attack will use. Fire Position This is the position the projectile will be fire at. Speed This is how fast the projectile shoots out. Target Time This is the cool down time between attacks. Projectile Script This is the basic projectile that your attack will use. Modifyable Variables Destroy Time This is the amount of time it will take before the projectile is destroy if it dosn't hit something.","title":"Attacking"},{"location":"Manual/Attacking/#attacking","text":"Our Attacking is a simple amie and fire system to damage the NPCs in the environment. This also correlates to the health bar on the NPCs. If the NPC doesn't have a health bar over it, you will not be able to attack it.","title":"Attacking"},{"location":"Manual/Attacking/#attacking-script","text":"","title":"Attacking Script"},{"location":"Manual/Attacking/#modifyable-variables","text":"These variables are open to your configuration to customize your controller the attck you want. Stats A reference to the player states. Projectile A reference to the projectile that the attack will use. Fire Position This is the position the projectile will be fire at. Speed This is how fast the projectile shoots out. Target Time This is the cool down time between attacks.","title":"Modifyable Variables"},{"location":"Manual/Attacking/#projectile-script","text":"This is the basic projectile that your attack will use.","title":"Projectile Script"},{"location":"Manual/Attacking/#modifyable-variables_1","text":"Destroy Time This is the amount of time it will take before the projectile is destroy if it dosn't hit something.","title":"Modifyable Variables"},{"location":"Manual/Included%20Defaults/","text":"Included Defaults To make things faster and easier, we've included some premade default utility scenes, scripts, and prefabs. You aren't required to use them, by any means, but they do accelerate early development and provide nice examples for beginners. Splash Screen Unity has a strange quirk where the first scene loaded after starting the game has many rendering functions reduced. The idea is that you use this scene exclusively to display your company logo or any other splash screens you need, but in practice even these can look bad. So to remedy this, we've included a simple blank black splash screen that automatically loads whatever you want your \"first\" proper scene to be. To use it, make sure that the Splash scene is first in your game's scene export order. Next, open up the Splash scene and click select the SplashController . Now in the Inspector tab, you should see a component you can control the values of. Delay: The number of seconds the splash screen will wait. You can set this to 0 to make it as instant as unity can handle. Next Scene: The exact case sensitive name of the scene you want the splash screen to change too when it's done. Main Menu A simple Main Menu made from Unity canvas components, includes a MainMenuHelper class that exposes arbitrary scene loading and game quitting functions to the unity Event System that canvas clicks can trigger. Note: Qutting the game functions do not work in the editor! (This is a quirk of Unity, there is a warning about it when a quit is requested.) Pause Menu A simple pause menu made from Unity canvas components, makes use of 'ToggleOnPause.cs' for main functionality. The pause menu has seven buttons, though the only two that currently function are the 'Resume' and 'Quit' buttons, which unpause the game and return to the main menu respectively. DemoScene We've included our own prototye environment that we used to test our own features.","title":"Included Defaults"},{"location":"Manual/Included%20Defaults/#included-defaults","text":"To make things faster and easier, we've included some premade default utility scenes, scripts, and prefabs. You aren't required to use them, by any means, but they do accelerate early development and provide nice examples for beginners.","title":"Included Defaults"},{"location":"Manual/Included%20Defaults/#splash-screen","text":"Unity has a strange quirk where the first scene loaded after starting the game has many rendering functions reduced. The idea is that you use this scene exclusively to display your company logo or any other splash screens you need, but in practice even these can look bad. So to remedy this, we've included a simple blank black splash screen that automatically loads whatever you want your \"first\" proper scene to be. To use it, make sure that the Splash scene is first in your game's scene export order. Next, open up the Splash scene and click select the SplashController . Now in the Inspector tab, you should see a component you can control the values of. Delay: The number of seconds the splash screen will wait. You can set this to 0 to make it as instant as unity can handle. Next Scene: The exact case sensitive name of the scene you want the splash screen to change too when it's done.","title":"Splash Screen"},{"location":"Manual/Included%20Defaults/#main-menu","text":"A simple Main Menu made from Unity canvas components, includes a MainMenuHelper class that exposes arbitrary scene loading and game quitting functions to the unity Event System that canvas clicks can trigger. Note: Qutting the game functions do not work in the editor! (This is a quirk of Unity, there is a warning about it when a quit is requested.)","title":"Main Menu"},{"location":"Manual/Included%20Defaults/#pause-menu","text":"A simple pause menu made from Unity canvas components, makes use of 'ToggleOnPause.cs' for main functionality. The pause menu has seven buttons, though the only two that currently function are the 'Resume' and 'Quit' buttons, which unpause the game and return to the main menu respectively.","title":"Pause Menu"},{"location":"Manual/Included%20Defaults/#demoscene","text":"We've included our own prototye environment that we used to test our own features.","title":"DemoScene"},{"location":"Manual/Language/","text":"Language This page serves as a dictionary for any Industry-specific jargon. FPS: Abreviation for \"First Person Shooter\". A game genre that includes navigating an environment from a first-person perspective. The name originally described a genre of violent gun games, but now the same core movement and mechanics describe a wide variety of nonviolent games as well. Nonviolent games tend to describe themselves as simply \"First Person\" games, but they still get sorted under the same \"FPS\" category by their mechanics. Mechanic: A discrete function or feature of a game. Often used to point to a function or feature, or groups of them as a reference in a larger discussion. Usefull in discussing the form and flow of interactive concepts.","title":"Language"},{"location":"Manual/Language/#language","text":"This page serves as a dictionary for any Industry-specific jargon. FPS: Abreviation for \"First Person Shooter\". A game genre that includes navigating an environment from a first-person perspective. The name originally described a genre of violent gun games, but now the same core movement and mechanics describe a wide variety of nonviolent games as well. Nonviolent games tend to describe themselves as simply \"First Person\" games, but they still get sorted under the same \"FPS\" category by their mechanics. Mechanic: A discrete function or feature of a game. Often used to point to a function or feature, or groups of them as a reference in a larger discussion. Usefull in discussing the form and flow of interactive concepts.","title":"Language"},{"location":"Manual/NPCs/","text":"NPC Our NPC is a genarice template for interactable people and enemies in the game. NPC Script This is a basic script with varaible that the NPC will use. Bar A reference to the NPC health bar. Stats A reference to the NPC states. Visibility This toggles if the health bar is shown or not. if shown the NPC can take damage but if not shown it will not take damage.","title":"NPC"},{"location":"Manual/NPCs/#npc","text":"Our NPC is a genarice template for interactable people and enemies in the game.","title":"NPC"},{"location":"Manual/NPCs/#npc-script","text":"This is a basic script with varaible that the NPC will use. Bar A reference to the NPC health bar. Stats A reference to the NPC states. Visibility This toggles if the health bar is shown or not. if shown the NPC can take damage but if not shown it will not take damage.","title":"NPC Script"},{"location":"Manual/Pausing%20API/","text":"Pausing Manager Pausing Manager is our custom pausing API that enables an easy to implement pausing functionality. As this is an API, most of the technical information will be in in-code documentation. However, we have provided a ToggleOnPause helper script that you can attach to objects to make certain things appear or disapear while paused or unpaused!","title":"Pausing Manager"},{"location":"Manual/Pausing%20API/#pausing-manager","text":"Pausing Manager is our custom pausing API that enables an easy to implement pausing functionality. As this is an API, most of the technical information will be in in-code documentation. However, we have provided a ToggleOnPause helper script that you can attach to objects to make certain things appear or disapear while paused or unpaused!","title":"Pausing Manager"},{"location":"Manual/Player%20Movement/","text":"Player Movement Our PlayerMovementController is a simple First-Person player controller similar to many games of the genre. The controller uses the Unity Input API to make configuring it's signals for different devices easier. The movement Controller also correctly responds to the Pausing API ! Any inputs given while the game is paused will be completely ignored, you must explicitly make the call to unpause the game from your pause menu. Modifyable Variables These variables are open to your configuration to customize your controller for your game. Camera Axis: A reference to the camera, or parent of the camera that should be directly rotated for vertical view rotation. The entire player object is rotated for horizontal view rotation. Mouse Sensitivity: A flat multiplier for the X and Y movement of the mouse respectively. DegreesPerSecondLookSpeed: The number of degrees per second the player's view is allowed to rotate. Max Angle: The furthest upward the player is able to look along the Y-Axis. Min Angle: The furthest downward the player is able to look along the Y-Axis. Movement Mult: A flat multiplier of player movement. Jump Force: A flat multiplier of the instantaneous physics force applied to perform a jump. You can think of this of the amount of force one pushes off the ground to perform a jump. Time Between Jumps: The time in seconds that must elapse between two jumps. Ground Detection Distance: The approximate distance from the bottom of the player a ground collider must be in order for a player to be considered \"on the ground\".","title":"Player Movement"},{"location":"Manual/Player%20Movement/#player-movement","text":"Our PlayerMovementController is a simple First-Person player controller similar to many games of the genre. The controller uses the Unity Input API to make configuring it's signals for different devices easier. The movement Controller also correctly responds to the Pausing API ! Any inputs given while the game is paused will be completely ignored, you must explicitly make the call to unpause the game from your pause menu.","title":"Player Movement"},{"location":"Manual/Player%20Movement/#modifyable-variables","text":"These variables are open to your configuration to customize your controller for your game. Camera Axis: A reference to the camera, or parent of the camera that should be directly rotated for vertical view rotation. The entire player object is rotated for horizontal view rotation. Mouse Sensitivity: A flat multiplier for the X and Y movement of the mouse respectively. DegreesPerSecondLookSpeed: The number of degrees per second the player's view is allowed to rotate. Max Angle: The furthest upward the player is able to look along the Y-Axis. Min Angle: The furthest downward the player is able to look along the Y-Axis. Movement Mult: A flat multiplier of player movement. Jump Force: A flat multiplier of the instantaneous physics force applied to perform a jump. You can think of this of the amount of force one pushes off the ground to perform a jump. Time Between Jumps: The time in seconds that must elapse between two jumps. Ground Detection Distance: The approximate distance from the bottom of the player a ground collider must be in order for a player to be considered \"on the ground\".","title":"Modifyable Variables"},{"location":"Manual/Statistics/","text":"Entity Statistics The Stats component tracks a player or entity's Health, Mana, and Stamina. For simplicity, all agents are assummed to have these stats, but some special agents you create may not use them all. Stats stores all the raw values as floats ( health , mana , stamina ) and limits them between 0 and a maximum value ( maxHealth , maxMana , maxStamina ).","title":"Entity Statistics"},{"location":"Manual/Statistics/#entity-statistics","text":"The Stats component tracks a player or entity's Health, Mana, and Stamina. For simplicity, all agents are assummed to have these stats, but some special agents you create may not use them all. Stats stores all the raw values as floats ( health , mana , stamina ) and limits them between 0 and a maximum value ( maxHealth , maxMana , maxStamina ).","title":"Entity Statistics"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/","text":"How to Contribute to Documentation We use MKDocs to generate static sites from simple markdown. Simply edit or create new Markdown ( .md ) files as needed. (Note: Make sure they have the .md extension! Editors like VSCode may detect the formatting in the file and treat them as markdown, but MKDocs does not.) You don't need to install it, simply pushing to the main branch will trigger a redeploy. For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"How to Contribute to Documentation"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/#how-to-contribute-to-documentation","text":"We use MKDocs to generate static sites from simple markdown. Simply edit or create new Markdown ( .md ) files as needed. (Note: Make sure they have the .md extension! Editors like VSCode may detect the formatting in the file and treat them as markdown, but MKDocs does not.) You don't need to install it, simply pushing to the main branch will trigger a redeploy. For full documentation visit mkdocs.org .","title":"How to Contribute to Documentation"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Team%20Policies/Team%20Policies/","text":"Team Policies Writen Documentation Every user story, the team members assigned to a specific user story are responsible for maintaining the relevant documentation pages that pertain to that user story. Every user story that relevantly requires updating the documentation should explicilty state updating the documentation as one of the requirements. In-Code Documentation Code Etiquite You should try to make each component modular, assembling it in a NEW scene (Not one of the prexisting ones) whenever possible and exporting it as a prefab. This way whenever someone begins to integrade it with the rest of the project; we can minimize same-scene editing and merge conflicts. Your code should use tripple slash comments with XML descriptors for API documentation (Visual Studio can generate this for you). You are also required to modify the documentation to describe how to use your new or modified feature in the Manual section.","title":"Team Policies"},{"location":"Team%20Policies/Team%20Policies/#team-policies","text":"","title":"Team Policies"},{"location":"Team%20Policies/Team%20Policies/#writen-documentation","text":"Every user story, the team members assigned to a specific user story are responsible for maintaining the relevant documentation pages that pertain to that user story. Every user story that relevantly requires updating the documentation should explicilty state updating the documentation as one of the requirements.","title":"Writen Documentation"},{"location":"Team%20Policies/Team%20Policies/#in-code-documentation","text":"","title":"In-Code Documentation"},{"location":"Team%20Policies/Team%20Policies/#code-etiquite","text":"You should try to make each component modular, assembling it in a NEW scene (Not one of the prexisting ones) whenever possible and exporting it as a prefab. This way whenever someone begins to integrade it with the rest of the project; we can minimize same-scene editing and merge conflicts. Your code should use tripple slash comments with XML descriptors for API documentation (Visual Studio can generate this for you). You are also required to modify the documentation to describe how to use your new or modified feature in the Manual section.","title":"Code Etiquite"},{"location":"Training/Unity3d/","text":"Unity3D Training The game engine we've chosen for this project thankfully has a comprehensive documentation site that includes both a general purpose manual and a scripting api . For more information please visit the official Unity Documentation! Crash Course Anything that has a spatial existance in the game engine is a GameObject, which can be toggled on and off and given a unique name. GameObjects automatically attach and are required to have a Transform Component that stores spatial data such as position, rotation, and scale. The Transform component is primarily used for 3D, but there is also a RectTransform variant with settings built for 2D games and UI systems. Unity uses a Component-based system for it's core game features. What this means is that you aren't going to be defining your features on the entities directly like object oriented systems; you'll be defining your features in terms of plugin-like script that gets attached to generic objects. You can still create your usual C# object oriented classes and define your own APIs. It's just the game content itself is built using a Component architecture. The MonoBehavior Class The MonoBehavior class is the Unity provided C# class that all your components will derive from. In fact when you create a script in-editor Unity will automatically create an templace C# script deriving from MonoBehavior and including some starter functions. This class provides access to a lot of engine features and provides a large host of Overridable Functions (see below) that are automatically called by the game engine at specific intervals and for specific reasons. Overridable Functions This is not all of the overridable functions! This is just a quick list for reference! Awake() Awake is called when the script is loaded on the object it's attached too. Notably other scripts or objects nearby may not be loaded yet! So it's best to only use this for internal setup. This only gets called once! Start() Start is called on the very first frame the game object is active and typically gaurunteed to be called after Awake() has been run. Note that this may not be run again if the game object is toggled use OnEnable() for things that need to be run every time the object is toggled on. Update() Update() is called every single frame. You can use Time.deltatime to get a float number that equals the number of simulation seconds since the last time update was called. You should generally only use this for calculations or physics that need to be run every frame, like player movement or vehicle control physics, anything framerate or camera dependent. Don't forget to scale any movement by Time.deltatime so that your movement code does not become arbitrarily framerate dependent. Time.deltatime will always scale proportionally with framerate, that way someone with twice the FPS as someone else doesn't unintentionally move twice as fast. FixedUpdate() FixedUpdate() runs on the game engine's physics tick. It's expensive to always be calculating physics every frame, so it delegates the physics crunching to a separate update cycle which runs at a more standardized number of times a second, reguardless of framerate. Just like Update() , you can use a similar value Time.fixedDeltatime to get the number of simulation seconds since the last FixedUpdate() was called in order to scale movement code accordingly. You should generally try to put any calculations or checks that need to run a lot here first to avoid running them an unnessecary number of times for every frame and driving down the framerate. If it's not framerate dependent; it should probably be here instead of Update() ; OnGUI() Similar to Update() , it runs on every frame. We will likely be using the UICanvas system for our UI so this may only be usefull for creating debug UI and visualizations, but still a good function to know about. OnEnable() Self explanatory, called every time the object gets enabled. OnDisable() Also self explanatory, called every time the object gets disabled. OnDestroy() Called once and only once when the object this script is attached to gets a call to be deleted or the scene it's in unloads. Usefull if you need to perform destructor like cleanup. Component Flags Require Component If you know your script needs access to a particular other component on the same gameobject, you can have the engine force this object to have that type of component by placing [RequireComponent(typeof(MyComponentClassname))] before your class declaration in your component's script. Whenever attatching your script, or if your script is saved in a prefab, the engine will automatically attach that script to the gameobject as well as prevent it's removal. Be careful with this however; it is not automatically reverssible . Don't Destroy On Load This is a weird flag that can only applied at runtime using DontDestroyOnLoad(referenceToObject); . What this does is prevent Destroy() from being automatically called on the object during scene changes, that's it! It's extremely usefull for singleton gameobjects or centralized managers that need to be tangible but should never be destroyed by scene changes. Importantly, but also obvious, you'll need to remember to manually call Destroy() on the object when you later do want to destroy it, especially on a scene change. Scene Loading Scene loading has an interesting architecture in Unity. Scenes must be predefined, and must be added to the build instructions in order to be loadable, period. You can add your scene to the build order by going to File > Build Settings... . Note that the first scene listed here will be the one that is automatically loaded first, so take consideration on where you put it in the list! In any script you can load a scene using the SceneManager.LoadScene(\"SceneName\"); function.","title":"Unity3D Training"},{"location":"Training/Unity3d/#unity3d-training","text":"The game engine we've chosen for this project thankfully has a comprehensive documentation site that includes both a general purpose manual and a scripting api . For more information please visit the official Unity Documentation!","title":"Unity3D Training"},{"location":"Training/Unity3d/#crash-course","text":"Anything that has a spatial existance in the game engine is a GameObject, which can be toggled on and off and given a unique name. GameObjects automatically attach and are required to have a Transform Component that stores spatial data such as position, rotation, and scale. The Transform component is primarily used for 3D, but there is also a RectTransform variant with settings built for 2D games and UI systems. Unity uses a Component-based system for it's core game features. What this means is that you aren't going to be defining your features on the entities directly like object oriented systems; you'll be defining your features in terms of plugin-like script that gets attached to generic objects. You can still create your usual C# object oriented classes and define your own APIs. It's just the game content itself is built using a Component architecture.","title":"Crash Course"},{"location":"Training/Unity3d/#the-monobehavior-class","text":"The MonoBehavior class is the Unity provided C# class that all your components will derive from. In fact when you create a script in-editor Unity will automatically create an templace C# script deriving from MonoBehavior and including some starter functions. This class provides access to a lot of engine features and provides a large host of Overridable Functions (see below) that are automatically called by the game engine at specific intervals and for specific reasons.","title":"The MonoBehavior Class"},{"location":"Training/Unity3d/#overridable-functions","text":"This is not all of the overridable functions! This is just a quick list for reference!","title":"Overridable Functions"},{"location":"Training/Unity3d/#awake","text":"Awake is called when the script is loaded on the object it's attached too. Notably other scripts or objects nearby may not be loaded yet! So it's best to only use this for internal setup. This only gets called once!","title":"Awake()"},{"location":"Training/Unity3d/#start","text":"Start is called on the very first frame the game object is active and typically gaurunteed to be called after Awake() has been run. Note that this may not be run again if the game object is toggled use OnEnable() for things that need to be run every time the object is toggled on.","title":"Start()"},{"location":"Training/Unity3d/#update","text":"Update() is called every single frame. You can use Time.deltatime to get a float number that equals the number of simulation seconds since the last time update was called. You should generally only use this for calculations or physics that need to be run every frame, like player movement or vehicle control physics, anything framerate or camera dependent. Don't forget to scale any movement by Time.deltatime so that your movement code does not become arbitrarily framerate dependent. Time.deltatime will always scale proportionally with framerate, that way someone with twice the FPS as someone else doesn't unintentionally move twice as fast.","title":"Update()"},{"location":"Training/Unity3d/#fixedupdate","text":"FixedUpdate() runs on the game engine's physics tick. It's expensive to always be calculating physics every frame, so it delegates the physics crunching to a separate update cycle which runs at a more standardized number of times a second, reguardless of framerate. Just like Update() , you can use a similar value Time.fixedDeltatime to get the number of simulation seconds since the last FixedUpdate() was called in order to scale movement code accordingly. You should generally try to put any calculations or checks that need to run a lot here first to avoid running them an unnessecary number of times for every frame and driving down the framerate. If it's not framerate dependent; it should probably be here instead of Update() ;","title":"FixedUpdate()"},{"location":"Training/Unity3d/#ongui","text":"Similar to Update() , it runs on every frame. We will likely be using the UICanvas system for our UI so this may only be usefull for creating debug UI and visualizations, but still a good function to know about.","title":"OnGUI()"},{"location":"Training/Unity3d/#onenable","text":"Self explanatory, called every time the object gets enabled.","title":"OnEnable()"},{"location":"Training/Unity3d/#ondisable","text":"Also self explanatory, called every time the object gets disabled.","title":"OnDisable()"},{"location":"Training/Unity3d/#ondestroy","text":"Called once and only once when the object this script is attached to gets a call to be deleted or the scene it's in unloads. Usefull if you need to perform destructor like cleanup.","title":"OnDestroy()"},{"location":"Training/Unity3d/#component-flags","text":"","title":"Component Flags"},{"location":"Training/Unity3d/#require-component","text":"If you know your script needs access to a particular other component on the same gameobject, you can have the engine force this object to have that type of component by placing [RequireComponent(typeof(MyComponentClassname))] before your class declaration in your component's script. Whenever attatching your script, or if your script is saved in a prefab, the engine will automatically attach that script to the gameobject as well as prevent it's removal. Be careful with this however; it is not automatically reverssible .","title":"Require Component"},{"location":"Training/Unity3d/#dont-destroy-on-load","text":"This is a weird flag that can only applied at runtime using DontDestroyOnLoad(referenceToObject); . What this does is prevent Destroy() from being automatically called on the object during scene changes, that's it! It's extremely usefull for singleton gameobjects or centralized managers that need to be tangible but should never be destroyed by scene changes. Importantly, but also obvious, you'll need to remember to manually call Destroy() on the object when you later do want to destroy it, especially on a scene change.","title":"Don't Destroy On Load"},{"location":"Training/Unity3d/#scene-loading","text":"Scene loading has an interesting architecture in Unity. Scenes must be predefined, and must be added to the build instructions in order to be loadable, period. You can add your scene to the build order by going to File > Build Settings... . Note that the first scene listed here will be the one that is automatically loaded first, so take consideration on where you put it in the list! In any script you can load a scene using the SceneManager.LoadScene(\"SceneName\"); function.","title":"Scene Loading"}]}