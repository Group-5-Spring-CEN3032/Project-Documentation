{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Welcome to MkDocs"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/","text":"How to Contribute to Documentation We use MKDocs to generate static sites from simple markdown. Simply edit or create new Markdown ( .md ) files as needed. (Note: Make sure they have the .md extension! Editors like VSCode may detect the formatting in the file and treat them as markdown, but MKDocs does not.) You don't need to install it, simply pushing to the main branch will trigger a redeploy. For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"How to Contribute to Documentation"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/#how-to-contribute-to-documentation","text":"We use MKDocs to generate static sites from simple markdown. Simply edit or create new Markdown ( .md ) files as needed. (Note: Make sure they have the .md extension! Editors like VSCode may detect the formatting in the file and treat them as markdown, but MKDocs does not.) You don't need to install it, simply pushing to the main branch will trigger a redeploy. For full documentation visit mkdocs.org .","title":"How to Contribute to Documentation"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"Team%20Policies/How%20to%20Contribute%20to%20Documentation/#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"Team%20Policies/Team%20Policies/","text":"Team Policies Writen Documentation Every user story, the team members assigned to a specific user story are responsible for maintaining the relevant documentation pages that pertain to that user story. Every user story that relevantly requires updating the documentation should explicilty state updating the documentation as one of the requirements. In-Code Documentation Code Etiquite You should try to make each component modular, assembling it in a NEW scene (Not one of the prexisting ones) whenever possible and exporting it as a prefab. This way whenever someone begins to integrade it with the rest of the project; we can minimize same-scene editing and merge conflicts. Your code should use tripple slash comments with XML descriptors for API documentation (Visual Studio can generate this for you). You are also required to modify the documentation to describe how to use your new or modified feature in the Manual section.","title":"Team Policies"},{"location":"Team%20Policies/Team%20Policies/#team-policies","text":"","title":"Team Policies"},{"location":"Team%20Policies/Team%20Policies/#writen-documentation","text":"Every user story, the team members assigned to a specific user story are responsible for maintaining the relevant documentation pages that pertain to that user story. Every user story that relevantly requires updating the documentation should explicilty state updating the documentation as one of the requirements.","title":"Writen Documentation"},{"location":"Team%20Policies/Team%20Policies/#in-code-documentation","text":"","title":"In-Code Documentation"},{"location":"Team%20Policies/Team%20Policies/#code-etiquite","text":"You should try to make each component modular, assembling it in a NEW scene (Not one of the prexisting ones) whenever possible and exporting it as a prefab. This way whenever someone begins to integrade it with the rest of the project; we can minimize same-scene editing and merge conflicts. Your code should use tripple slash comments with XML descriptors for API documentation (Visual Studio can generate this for you). You are also required to modify the documentation to describe how to use your new or modified feature in the Manual section.","title":"Code Etiquite"},{"location":"Training/Unity3d/","text":"Unity3D Training The game engine we've chosen for this project thankfully has a comprehensive documentation site that includes both a general purpose manual and a scripting api . For more information please visit the official Unity Documentation! Crash Course Anything that has a spatial existance in the game engine is a GameObject, which can be toggled on and off and given a unique name. GameObjects automatically attach and are required to have a Transform Component that stores spatial data such as position, rotation, and scale. The Transform component is primarily used for 3D, but there is also a RectTransform variant with settings built for 2D games and UI systems. Unity uses a Component-based system for it's core game features. What this means is that you aren't going to be defining your features on the entities directly like object oriented systems; you'll be defining your features in terms of plugin-like script that gets attached to generic objects. You can still create your usual C# object oriented classes and define your own APIs. It's just the game content itself is built using a Component architecture. The MonoBehavior Class The MonoBehavior class is the Unity provided C# class that all your components will derive from. In fact when you create a script in-editor Unity will automatically create an templace C# script deriving from MonoBehavior and including some starter functions. This class provides access to a lot of engine features and provides a large host of Overridable Functions (see below) that are automatically called by the game engine at specific intervals and for specific reasons. Overridable Functions This is not all of the overridable functions! This is just a quick list for reference! Awake() Awake is called when the script is loaded on the object it's attached too. Notably other scripts or objects nearby may not be loaded yet! So it's best to only use this for internal setup. This only gets called once! Start() Start is called on the very first frame the game object is active and typically gaurunteed to be called after Awake() has been run. Note that this may not be run again if the game object is toggled use OnEnable() for things that need to be run every time the object is toggled on. Update() Update() is called every single frame. You can use Time.deltatime to get a float number that equals the number of simulation seconds since the last time update was called. You should generally only use this for calculations or physics that need to be run every frame, like player movement or vehicle control physics, anything framerate or camera dependent. Don't forget to scale any movement by Time.deltatime so that your movement code does not become arbitrarily framerate dependent. Time.deltatime will always scale proportionally with framerate, that way someone with twice the FPS as someone else doesn't unintentionally move twice as fast. FixedUpdate() FixedUpdate() runs on the game engine's physics tick. It's expensive to always be calculating physics every frame, so it delegates the physics crunching to a separate update cycle which runs at a more standardized number of times a second, reguardless of framerate. Just like Update() , you can use a similar value Time.fixedDeltatime to get the number of simulation seconds since the last FixedUpdate() was called in order to scale movement code accordingly. You should generally try to put any calculations or checks that need to run a lot here first to avoid running them an unnessecary number of times for every frame and driving down the framerate. If it's not framerate dependent; it should probably be here instead of Update() ; OnGUI() Similar to Update() , it runs on every frame. We will likely be using the UICanvas system for our UI so this may only be usefull for creating debug UI and visualizations, but still a good function to know about. OnEnable() Self explanatory, called every time the object gets enabled. OnDisable() Also self explanatory, called every time the object gets disabled. OnDestroy() Called once and only once when the object this script is attached to gets a call to be deleted or the scene it's in unloads. Usefull if you need to perform destructor like cleanup. Component Flags Require Component If you know your script needs access to a particular other component on the same gameobject, you can have the engine force this object to have that type of component by placing [RequireComponent(typeof(MyComponentClassname))] before your class declaration in your component's script. Whenever attatching your script, or if your script is saved in a prefab, the engine will automatically attach that script to the gameobject as well as prevent it's removal. Be careful with this however; it is not automatically reverssible . Don't Destroy On Load This is a weird flag that can only applied at runtime using DontDestroyOnLoad(referenceToObject); . What this does is prevent Destroy() from being automatically called on the object during scene changes, that's it! It's extremely usefull for singleton gameobjects or centralized managers that need to be tangible but should never be destroyed by scene changes. Importantly, but also obvious, you'll need to remember to manually call Destroy() on the object when you later do want to destroy it, especially on a scene change. Scene Loading Scene loading has an interesting architecture in Unity. Scenes must be predefined, and must be added to the build instructions in order to be loadable, period. You can add your scene to the build order by going to File > Build Settings... . Note that the first scene listed here will be the one that is automatically loaded first, so take consideration on where you put it in the list! In any script you can load a scene using the SceneManager.LoadScene(\"SceneName\"); function.","title":"Unity3D Training"},{"location":"Training/Unity3d/#unity3d-training","text":"The game engine we've chosen for this project thankfully has a comprehensive documentation site that includes both a general purpose manual and a scripting api . For more information please visit the official Unity Documentation!","title":"Unity3D Training"},{"location":"Training/Unity3d/#crash-course","text":"Anything that has a spatial existance in the game engine is a GameObject, which can be toggled on and off and given a unique name. GameObjects automatically attach and are required to have a Transform Component that stores spatial data such as position, rotation, and scale. The Transform component is primarily used for 3D, but there is also a RectTransform variant with settings built for 2D games and UI systems. Unity uses a Component-based system for it's core game features. What this means is that you aren't going to be defining your features on the entities directly like object oriented systems; you'll be defining your features in terms of plugin-like script that gets attached to generic objects. You can still create your usual C# object oriented classes and define your own APIs. It's just the game content itself is built using a Component architecture.","title":"Crash Course"},{"location":"Training/Unity3d/#the-monobehavior-class","text":"The MonoBehavior class is the Unity provided C# class that all your components will derive from. In fact when you create a script in-editor Unity will automatically create an templace C# script deriving from MonoBehavior and including some starter functions. This class provides access to a lot of engine features and provides a large host of Overridable Functions (see below) that are automatically called by the game engine at specific intervals and for specific reasons.","title":"The MonoBehavior Class"},{"location":"Training/Unity3d/#overridable-functions","text":"This is not all of the overridable functions! This is just a quick list for reference!","title":"Overridable Functions"},{"location":"Training/Unity3d/#awake","text":"Awake is called when the script is loaded on the object it's attached too. Notably other scripts or objects nearby may not be loaded yet! So it's best to only use this for internal setup. This only gets called once!","title":"Awake()"},{"location":"Training/Unity3d/#start","text":"Start is called on the very first frame the game object is active and typically gaurunteed to be called after Awake() has been run. Note that this may not be run again if the game object is toggled use OnEnable() for things that need to be run every time the object is toggled on.","title":"Start()"},{"location":"Training/Unity3d/#update","text":"Update() is called every single frame. You can use Time.deltatime to get a float number that equals the number of simulation seconds since the last time update was called. You should generally only use this for calculations or physics that need to be run every frame, like player movement or vehicle control physics, anything framerate or camera dependent. Don't forget to scale any movement by Time.deltatime so that your movement code does not become arbitrarily framerate dependent. Time.deltatime will always scale proportionally with framerate, that way someone with twice the FPS as someone else doesn't unintentionally move twice as fast.","title":"Update()"},{"location":"Training/Unity3d/#fixedupdate","text":"FixedUpdate() runs on the game engine's physics tick. It's expensive to always be calculating physics every frame, so it delegates the physics crunching to a separate update cycle which runs at a more standardized number of times a second, reguardless of framerate. Just like Update() , you can use a similar value Time.fixedDeltatime to get the number of simulation seconds since the last FixedUpdate() was called in order to scale movement code accordingly. You should generally try to put any calculations or checks that need to run a lot here first to avoid running them an unnessecary number of times for every frame and driving down the framerate. If it's not framerate dependent; it should probably be here instead of Update() ;","title":"FixedUpdate()"},{"location":"Training/Unity3d/#ongui","text":"Similar to Update() , it runs on every frame. We will likely be using the UICanvas system for our UI so this may only be usefull for creating debug UI and visualizations, but still a good function to know about.","title":"OnGUI()"},{"location":"Training/Unity3d/#onenable","text":"Self explanatory, called every time the object gets enabled.","title":"OnEnable()"},{"location":"Training/Unity3d/#ondisable","text":"Also self explanatory, called every time the object gets disabled.","title":"OnDisable()"},{"location":"Training/Unity3d/#ondestroy","text":"Called once and only once when the object this script is attached to gets a call to be deleted or the scene it's in unloads. Usefull if you need to perform destructor like cleanup.","title":"OnDestroy()"},{"location":"Training/Unity3d/#component-flags","text":"","title":"Component Flags"},{"location":"Training/Unity3d/#require-component","text":"If you know your script needs access to a particular other component on the same gameobject, you can have the engine force this object to have that type of component by placing [RequireComponent(typeof(MyComponentClassname))] before your class declaration in your component's script. Whenever attatching your script, or if your script is saved in a prefab, the engine will automatically attach that script to the gameobject as well as prevent it's removal. Be careful with this however; it is not automatically reverssible .","title":"Require Component"},{"location":"Training/Unity3d/#dont-destroy-on-load","text":"This is a weird flag that can only applied at runtime using DontDestroyOnLoad(referenceToObject); . What this does is prevent Destroy() from being automatically called on the object during scene changes, that's it! It's extremely usefull for singleton gameobjects or centralized managers that need to be tangible but should never be destroyed by scene changes. Importantly, but also obvious, you'll need to remember to manually call Destroy() on the object when you later do want to destroy it, especially on a scene change.","title":"Don't Destroy On Load"},{"location":"Training/Unity3d/#scene-loading","text":"Scene loading has an interesting architecture in Unity. Scenes must be predefined, and must be added to the build instructions in order to be loadable, period. You can add your scene to the build order by going to File > Build Settings... . Note that the first scene listed here will be the one that is automatically loaded first, so take consideration on where you put it in the list! In any script you can load a scene using the SceneManager.LoadScene(\"SceneName\"); function.","title":"Scene Loading"}]}